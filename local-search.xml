<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>webpack-bundle-analyzer使用</title>
    <link href="/2023/06/10/webpack-bundle-analyzer%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/06/10/webpack-bundle-analyzer%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、安装（Nuxt项目中）"><a href="#一、安装（Nuxt项目中）" class="headerlink" title="一、安装（Nuxt项目中）"></a>一、安装（<code>Nuxt</code>项目中）</h3><p>​地址：<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">https://github.com/webpack-contrib/webpack-bundle-analyzer</a></p><ol><li><p><code>npm install --save-dev webpack-bundle-analyzer</code></p></li><li><p><code>nuxt.config.js</code>文件中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">const</span> <span class="hljs-string">BundleAnalyzerPlugin</span> <span class="hljs-string">=</span> <span class="hljs-string">require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin;</span><br><br><span class="hljs-string">export</span> <span class="hljs-string">default</span> &#123;<br><span class="hljs-attr">build:</span> &#123;<br>        <span class="hljs-attr">analyze:</span> <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">plugins:</span> [<br>          <span class="hljs-string">new</span> <span class="hljs-string">BundleAnalyzerPlugin(</span>&#123;<br>            <span class="hljs-attr">analyzerMode:</span> <span class="hljs-string">&#x27;server&#x27;</span>,<br>            <span class="hljs-attr">analyzerHost:</span> <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>        <span class="hljs-attr">analyzerPort:</span> <span class="hljs-number">8889</span>,<br>            <span class="hljs-attr">generateStatsFile:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">statsOptions:</span> &#123; <span class="hljs-attr">source:</span> <span class="hljs-literal">false</span> &#125;<br>          &#125;<span class="hljs-string">)</span><br>        ]<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>package.json</code>文件中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;analyz&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env YXT_ENV=production npm_config_report=true npm run build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后可以通过<code>npm run build</code>命令来启动，这些文件名可以提前在步骤二中配置。可以通过这些文件查看打包报告，也可以通过配置的域名和端口号来查看</p><p><img src="/2023/06/10/webpack-bundle-analyzer%E4%BD%BF%E7%94%A8/image-20220330105429341.png" alt="image-20220330105429341"></p></li><li><p>出现报错</p><p><img src="/2023/06/10/webpack-bundle-analyzer%E4%BD%BF%E7%94%A8/image-20220330105545044.png" alt="image-20220330105545044"></p></li></ol><p>​显示<code>address</code>已经被使用，换了几个地址还是报同样的错，就暂时没处理了</p><h3 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h3><p>​<img src="/2023/06/10/webpack-bundle-analyzer%E4%BD%BF%E7%94%A8/image-20220330110627594.png" alt="image-20220330110627594"></p><ol><li><code>stat</code>:文件“输入”时大小，没经过任何转换</li><li><code>parsed</code>: 文件“输出”时大小。如果使用了<code>Uglify</code>之类的<code>webpack</code>插件，这个值会反映代码缩小后的大小</li><li><code>gzip</code>：通过<code>gzip</code>压缩所运行的解析包&#x2F;模块的大小</li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化CommonJs和ES6</title>
    <link href="/2023/06/10/%E6%A8%A1%E5%9D%97%E5%8C%96CommonJs%E5%92%8CES6/"/>
    <url>/2023/06/10/%E6%A8%A1%E5%9D%97%E5%8C%96CommonJs%E5%92%8CES6/</url>
    
    <content type="html"><![CDATA[<p>   再次去看<code>webpack</code>打包原理的时候，发现对于<code>import/export</code>和<code>report/exports</code>的概念已经模糊了，另外写代码的过程中偶尔会出现报错的情况，于是重新整理一下~</p><h3 id="一、概念与原理"><a href="#一、概念与原理" class="headerlink" title="一、概念与原理"></a>一、概念与原理</h3><ol><li><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li><p><code>require/exports</code>属于<code>CommonJS</code>模块化方案，为服务器端开发而设计，服务器模块系统<strong>同步</strong>读取模块文件内容。<code>Node.js</code>是<code>CommonJs</code>规范的实现</p></li><li><p><code>import/export</code>属于<code>ES6</code>的模块化方案，为浏览器而设计</p></li></ul></li><li><h4 id="加载区别"><a href="#加载区别" class="headerlink" title="加载区别"></a>加载区别</h4><ul><li><code>require/exports(module.exports)</code><ul><li>属于动态语法，可以写在判断里。所谓动态语法，是在运行期间检查数据类型</li><li>模块运行时加载</li><li>遇到循环依赖时，只会输出已经执行的部分，后续的输出或者变化，是不会 影响已经输出的变量的</li><li><code>require</code>语法是同步的，只适合在服务端</li><li><code>require</code>加载的是一个对象，只会在脚本运行完后，有且只有一次生成，即使多次执行一个模块的<code>require</code>命令，它也只会在第一次加载时运行一次，后面都会从缓存中读取，除非手动清除缓存</li><li><code>exports</code>导出的是值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值了</li><li>使用<code>module.exports</code>导出时，本质是导出<code>exports</code>这个对象，当这个对象不导出任何东西时，它本身是一个空对象</li></ul></li><li><code>import/export(export default)</code><ul><li><pre><code class="hljs">                                                                                                                                                               是静态语法，只能写在顶层。所谓静态语法，会在运行前编译时检查类型</code></pre></li><li><pre><code class="hljs">                                                                                                                                                               编译时加载</code></pre></li><li><pre><code class="hljs">                                                                                                                                                               在浏览器端和服务端均可以使用，但是在服务端需要遵循一些特殊的规则</code></pre></li><li><pre><code class="hljs">                                                                                                                                                               `import`加载的是一个变量，不会被缓存，真正取值的时候就能取到最终的值</code></pre></li><li><pre><code class="hljs">                                                                                                                                                               `export`导出的是变量的引用(`export default`例外)，当脚本真正执行的时候再根据这个只读引用到被加载的那个模块去取值</code></pre></li><li><pre><code class="hljs">                                                                                                                                                               使用`export`导出时，本质是导出`default`这个对象</code></pre></li></ul></li></ul></li><li><h4 id="用法区别"><a href="#用法区别" class="headerlink" title="用法区别"></a>用法区别</h4><ul><li><p><code>require/exports(module.exports)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// require</span><br><span class="hljs-type">const</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// exports</span><br><span class="hljs-keyword">exports</span>.fs = fs<br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = fs<br></code></pre></td></tr></table></figure></li><li><p><code>import/export(export default)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// import</span><br><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> lib <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./lib&#x27;</span><br><span class="hljs-keyword">import</span> &#123;readfile&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span><br><br><span class="hljs-comment">// export</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> fs<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span>/<span class="hljs-keyword">let</span> fs = ...<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readfile</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="二、exports-module-exports和export-export-default"><a href="#二、exports-module-exports和export-export-default" class="headerlink" title="二、exports/module.exports和export/export default"></a>二、<code>exports/module.exports</code>和<code>export/export default</code></h3><ol><li><p><code>exports/module.exports</code></p><ul><li><p>每个模块都有一个<code>module</code>对象，<code>module</code>对象中有一个<code>exports</code>对象，可以将需要导出的成员挂载到<code>module.exports</code>接口对象中</p></li><li><p><code>exports</code>是<code>module.exports</code>的一个引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">exports</span> <span class="hljs-operator">=</span> module.exports <span class="hljs-operator">=</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>导出单个成员时，必须使用<code>module.exports = xxx</code>的方式，使用<code>exports=xxx</code>不管用，因为最终向外return的永远是<code>module.exports</code>，使用<code>exports=xxx</code>只会改变引用关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导出多个对象</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">a</span> = ...<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">b</span> = ...<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">add</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;,<br><span class="hljs-attr">str</span>:<span class="hljs-string">&#x27;hello&#x27;</span>,<br>...<br>&#125;<br><br><span class="hljs-comment">// 导出单个对象</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-comment">// 上面的情况，后者会覆盖前者</span><br></code></pre></td></tr></table></figure></li><li><p>当<code>module.exports = xxx</code>后，再往<code>exports</code>添加导出成员也不起作用了，因为此时<code>module.exports</code>改变了指向对象。可以通过<code>exports = module.exports</code>重新建立引用关系</p></li></ul></li><li><p><code>export/export default</code></p><ul><li><p><code>export</code>绑定到标识符，改变标识符的值(<em>注：模块导出的属性和方法只能在模块内修改，<strong>不能在导入模块的地方修改</strong></em>)，然后访问这个绑定，得到的是新值</p></li><li><p><code>export default</code>绑定的是标识符指向的值，如果修改标识符指向另一个值，这个绑定的值不会发生变化。可以通过以下方式修改默认导出的值</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> &#123;fs <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>export</code>：<strong>命名导出</strong>，可以导出多个值；在导入过程中必须使用对应对象的相同名称</p></li><li><p><code>export defalut</code>：<strong>默认导出</strong>，仅导出单个值；在导入过程中可以使用任何名称进行导入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// export</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> name1 = ..., name2= ...,<br><span class="hljs-keyword">export</span> &#123;<span class="hljs-built_in">object</span>, <span class="hljs-built_in">number</span>, x, y, <span class="hljs-built_in">string</span>&#125;<br><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-built_in">object</span>, x&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module&#x27;</span><br><br><span class="hljs-comment">// export default</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">4</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> x<br><br><span class="hljs-keyword">import</span> y <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module&#x27;</span><br><br><br></code></pre></td></tr></table></figure></li><li><p>每个模块最多只有一个”<strong>默认导出</strong>“，但可以有多个”<strong>命名导出</strong>“</p></li></ul></li></ol><h3 id="三、容易出错的点"><a href="#三、容易出错的点" class="headerlink" title="三、容易出错的点"></a>三、容易出错的点</h3><ol><li><p>在<code>webpack</code>打包时，可以在<code>js</code>文件中混用<code>require</code>和<code>export</code>，但不能混用<code>import</code>和<code>module.exports</code>不然会报错<img src="/2023/06/10/%E6%A8%A1%E5%9D%97%E5%8C%96CommonJs%E5%92%8CES6/image-20220405210440844.png" alt="image-20220405210440844"></p><ul><li><p>解决方式：可以统一改成<code>ES6</code>的方式进行编写</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> normalTime<br><br><span class="hljs-keyword">import</span> nomalTime <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>对于”<strong>命名导出</strong>“，导入的时候需要包裹在花括号中；对于”<strong>默认导出</strong>“，导入的时候不要用花括号包裹。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导出</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> num = <span class="hljs-number">33</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">import</span> sum, &#123;num&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index&#x27;</span>;<br><br></code></pre></td></tr></table></figure><p>同样的，在使用<code>export default</code>时，不要使用</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span>&#125;<br><br><span class="hljs-keyword">import</span> &#123;a, b, c&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math&#x27;</span><br></code></pre></td></tr></table></figure><p>虽然在<code>babel5</code>中可以正常被解析，但在<code>babel6</code>中<code>a</code> <code>b</code> <code>c</code>均为<code>undefined</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取文档目录生成导航的实现</title>
    <link href="/2023/04/06/%E8%8E%B7%E5%8F%96%E6%96%87%E6%A1%A3%E7%9B%AE%E5%BD%95%E7%94%9F%E6%88%90%E5%AF%BC%E8%88%AA%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/04/06/%E8%8E%B7%E5%8F%96%E6%96%87%E6%A1%A3%E7%9B%AE%E5%BD%95%E7%94%9F%E6%88%90%E5%AF%BC%E8%88%AA%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="1-获取文档目录"><a href="#1-获取文档目录" class="headerlink" title="(1) 获取文档目录"></a>(1) 获取文档目录</h4><p>因为文档的数据是通过接口请求数据之后进行渲染的，所以本人是在接口数据请求回来之后的<code>nextTick</code>中去获取文档目录的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">const markMenu = <span class="hljs-selector-attr">[]</span><br>const headings = document<span class="hljs-selector-class">.querySelectorAll</span>(<span class="hljs-string">&#x27;h1, h2, h3, h4&#x27;</span>)<br><span class="hljs-keyword">if</span> (headings) &#123;<br>  <span class="hljs-keyword">for</span> (const ele of headings) &#123;<br>    const <span class="hljs-selector-tag">i</span> = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;h2&#x27;</span>, <span class="hljs-string">&#x27;h3&#x27;</span>, <span class="hljs-string">&#x27;h4&#x27;</span>]</span><span class="hljs-selector-class">.indexOf</span>(ele<span class="hljs-selector-class">.tagName</span><span class="hljs-selector-class">.toLowerCase</span>())<br>    <span class="hljs-keyword">if</span> (<span class="hljs-selector-tag">i</span> &gt; -<span class="hljs-number">1</span> &amp;&amp; ele.textContent) &#123;<br>      ele<span class="hljs-selector-class">.setAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;markMenu_&#x27;</span> + markMenu.length)<br>      ele<span class="hljs-selector-class">.setAttribute</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;markMenu_&#x27;</span> + markMenu.length)<br>      markMenu<span class="hljs-selector-class">.push</span>(&#123;<br>        level: <span class="hljs-selector-tag">i</span>,<br>        text: ele<span class="hljs-selector-class">.textContent</span>,<br>        id: <span class="hljs-string">&#x27;markMenu_&#x27;</span> + markMenu<span class="hljs-selector-class">.length</span>,<br>        name: <span class="hljs-string">&#x27;markMenu_&#x27;</span> + markMenu<span class="hljs-selector-class">.length</span><br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实践输出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>highlightjs使用</title>
    <link href="/2023/04/03/highlightjs%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/03/highlightjs%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>搜很很多<code>blog</code> 以及看官方文档，引入的方式以及调用的<code>api</code>都不太一致，记录一下本人在项目中配置生效的方案</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i highlight.js<br></code></pre></td></tr></table></figure></li><li><p>引入（封装了代码高亮组件，直接在组件中引入了）</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> hljs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;highlight.js&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;highlight.js/styles/atom-one-light.css&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><code>template</code>代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;`language-$&#123;language&#125;`&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">code</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>若一个页面中多次用到高亮组件，配置<code>id</code>，不然会出现意想不到的错误；<code>language</code>为代码语言类型；<code>code</code>为代码</p></li><li><p>执行高亮</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">mounted</span><span class="hljs-params">()</span></span> &#123;<br>  hljs<span class="hljs-selector-class">.highlightAll</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>所有在<code>pre code</code>中的代码都会被高亮 ；默认的<code>css</code>选择器为<code>pre code</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第三方库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扫普通链接二维码打开小程序&amp;&amp;微信sdk引入实现</title>
    <link href="/2022/11/21/%E6%89%AB%E6%99%AE%E9%80%9A%E9%93%BE%E6%8E%A5%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%93%E5%BC%80%E5%B0%8F%E7%A8%8B%E5%BA%8F&amp;&amp;%E5%BE%AE%E4%BF%A1sdk%E5%BC%95%E5%85%A5%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/11/21/%E6%89%AB%E6%99%AE%E9%80%9A%E9%93%BE%E6%8E%A5%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%93%E5%BC%80%E5%B0%8F%E7%A8%8B%E5%BA%8F&amp;&amp;%E5%BE%AE%E4%BF%A1sdk%E5%BC%95%E5%85%A5%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、扫描普通二维码"><a href="#一、扫描普通二维码" class="headerlink" title="一、扫描普通二维码"></a>一、扫描普通二维码</h3><h3 id="1-需求场景描述"><a href="#1-需求场景描述" class="headerlink" title="(1) 需求场景描述"></a>(1) 需求场景描述</h3><p>​ 需要将固定地址（小程序相关）&amp;动态key值拼接，并生成二维码。微信扫码识别可进入小程序，在小程序中可获取该动态key值</p><h3 id="2-配置步骤"><a href="#2-配置步骤" class="headerlink" title="(2) 配置步骤"></a>(2) 配置步骤</h3><p><a href="https://developers.weixin.qq.com/miniprogram/introduction/qrcode.html#%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D">微信文档：扫普通链接二维码打开小程序</a></p><pre><code class="hljs">1. 登录小程序进行配置。 - 开发管理 -&gt; 开发设置 -&gt; 扫普通链接二维码打开小程序, 配置二维码跳转规则（可参考提示）。注：未成功跳转时，可对照常见匹配错误进行排查</code></pre><ol start="2"><li><p>配置二维码跳转时，根据提示路径，将随机校验文件下载后放在对应服务器路径下</p></li><li><p>在开发设置中配置服务器合法域名，即在小程序中会访问到的</p></li><li><p>小程序代码发布成功之后，才可发布二维码跳转规则</p></li></ol><h3 id="3-小程序中获取内容"><a href="#3-小程序中获取内容" class="headerlink" title="(3) 小程序中获取内容"></a>(3) 小程序中获取内容</h3><p>​二维码链接内容会以参数 <code>q</code> 的形式带给页面，在 <code>onLoad </code>事件中提取 <code>q</code> 参数并自行 <code>decodeURIComponent</code> 一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Page</span>(&#123;<br>  <span class="hljs-title function_">onLoad</span>(<span class="hljs-params">query</span>) &#123;<br>    <span class="hljs-keyword">const</span> q = <span class="hljs-built_in">decodeURIComponent</span>(query.<span class="hljs-property">q</span>) <span class="hljs-comment">// 获取到二维码原始链接内容</span><br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="4-小程序开发遇到的一些坑"><a href="#4-小程序开发遇到的一些坑" class="headerlink" title="(4) 小程序开发遇到的一些坑"></a>(4) 小程序开发遇到的一些坑</h3><ol><li><p><code>.js</code>文件中访问<code>data</code>中的数据时，正确格式是：<code>this.data.xxx</code></p></li><li><p><code>const q = decodeURIComponent(query.q)</code>， <code>q</code>的值是<code>string</code>类型，若考虑<code>q</code>为<code>undefined</code>的判断，<code>if(q === undefined)</code>是无法生效的，需要改为<code>if(q === &#39;undefined&#39;)</code></p></li></ol><h4 id="二、引入微信sdk，实现h5分享到微信好友和朋友圈"><a href="#二、引入微信sdk，实现h5分享到微信好友和朋友圈" class="headerlink" title="二、引入微信sdk，实现h5分享到微信好友和朋友圈"></a>二、引入微信sdk，实现h5分享到微信好友和朋友圈</h4><h3 id="1-引入之前需要注意"><a href="#1-引入之前需要注意" class="headerlink" title="(1) 引入之前需要注意"></a>(1) 引入之前需要注意</h3><ol><li><code>h5</code>中引入微信<code>sdk</code>，用来配置的公众号必须是企业号，认证通过之后才可以有分享接口权限</li><li>在接口权限中确认，需要调用的接口该公众号是否有权限</li></ol><h3 id="2-配置流程"><a href="#2-配置流程" class="headerlink" title="(2) 配置流程"></a>(2) 配置流程</h3><p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html">Js-sdk引入</a></p><ol><li><h4 id="微信公众平台配置"><a href="#微信公众平台配置" class="headerlink" title="微信公众平台配置"></a>微信公众平台配置</h4><ul><li>登录微信公众平台，设置与开发 -&gt; 公众号设置 -&gt; 功能设置，填写js安全域名，该处域名我填了两个：项目测试环境域名和产线环境域名。此步骤实际上是将分享页面所在域名与使用的<code>appid</code>绑定，注意填写正确<ul><li>域名必须通过了ICP备案的验证</li></ul></li><li>将校验文件上传至指定服务器<ul><li>上传后且校验文件可访问的情况下，域名才能添加成功</li></ul></li></ul></li><li><h4 id="后端配置"><a href="#后端配置" class="headerlink" title="后端配置"></a>后端配置</h4><ul><li><p>根据公众号的<code>appId</code>和<code>appscret</code>通过 <a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret%E8%8E%B7%E5%8F%96%60access_token%60">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret获取`access_token`</a>, 参考<a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html"><code>access_token</code>获取</a></p></li><li><p>根据上一步的<code>access_token</code>获取通过<a href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi%E8%8E%B7%E5%8F%96%60jsapi_ticket%60">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi获取`jsapi_ticket`</a></p></li><li><p>根据上一步的<code>jsapi_ticket</code>生成签名，举例</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">noncestr</span>=Wm3WZYTPz0wzccnW<br><span class="hljs-attr">jsapi_ticket</span>=sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg<br><span class="hljs-attr">timestamp</span>=<span class="hljs-number">1414587457</span><br><span class="hljs-attr">url</span>=http://mp.weixin.qq.com?params=value<br></code></pre></td></tr></table></figure></li></ul></li><li><h4 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h4><ul><li><p>在每个需要使用sdk的页面都注入配置，在SPA Vue项目中，可以将配置注入放在<code>router.beforeEach</code>中</p></li><li><p>通过<code>wx.config</code>进行配置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">wx.config(&#123;<br>  debug: true, <span class="hljs-regexp">//</span> 开启调试模式,调用的所有 api 的返回值会在客户端 alert 出来，若要查看传入的参数，可以在 pc 端打开，参数信息会通过 log 打出，仅在 pc 端时才会打印。<br>  appId: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-regexp">//</span> 必填，公众号的唯一标识<br>  timestamp: , <span class="hljs-regexp">//</span> 必填，生成签名的时间戳<br>  nonceStr: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-regexp">//</span> 必填，生成签名的随机串<br>  signature: <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-regexp">//</span> 必填，签名<br>  jsApiList: [] <span class="hljs-regexp">//</span> 必填，需要使用的 JS 接口列表<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>在<code>wx.ready</code>里调用分享接口</p></li></ul></li></ol><h3 id="3-注意点"><a href="#3-注意点" class="headerlink" title="(3) 注意点"></a>(3) 注意点</h3><ol><li><h4 id="前端配置-1"><a href="#前端配置-1" class="headerlink" title="前端配置"></a>前端配置</h4><ul><li><p>传递给后端生成签名的<code>url</code>需要除去’#’hash部分的链接（可用<code>location.href.split(&#39;#&#39;)[0]</code>获取），而且需要<code>encodeURIComponent</code></p></li><li><p>前端配置<code>wx.config</code>用到的时间戳、随机串、<code>appId</code>等必须和后端生成签名算法时用到的保持一致，因此这块直接采用后端用于生成签名的数据进行配置。另外注意配置时候<code>nonceStr</code>是驼峰写法，配置出错时先检查配置字段的<code>key</code></p></li><li><p>分享接口里配置的<code>url</code>是无需<code>encodeURIComponent</code>的，就是分享页面的<code>url</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">wx.ready(<span class="hljs-keyword">function</span> () &#123;   <span class="hljs-regexp">//</span>需在用户可能点击分享按钮前就先调用<br>  wx.updateAppMessageShareData(&#123; <br>    title: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-regexp">//</span> 分享标题<br>    desc: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-regexp">//</span> 分享描述<br>    link: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-regexp">//</span> 分享链接，该链接域名或路径必须与当前页面对应的公众号 JS 安全域名一致<br>    imgUrl: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-regexp">//</span> 分享图标<br>    success: <span class="hljs-keyword">function</span> () &#123;<br>      <span class="hljs-regexp">//</span> 设置成功<br>    &#125;<br>  &#125;)<br>&#125;); <br></code></pre></td></tr></table></figure></li><li><p><code>wx.ready</code>里所有需要调用的接口，都要在<code>wx.config  jsApiList</code>中进行配置</p></li></ul></li><li><h4 id="后端配置-1"><a href="#后端配置-1" class="headerlink" title="后端配置"></a>后端配置</h4><ul><li>生成签名的时候需要先将<code>url</code> 进行<code>decode</code></li><li>可以先通过<a href="http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign">http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign</a> 对生成的签名进行校验</li><li>确保<code>appId</code>和<code>appSecret</code>一定正确，不要有缓存之类的影响</li><li>正常情况下，<code>access_token</code>和<code>jsapi_ticket</code>的有效期为7200秒内，重复获取将导致上次获取的<code>access_token</code>失效，确保一定缓存<code>access_token</code>和<code>jsapi_ticket</code>，且需要定时刷新</li><li>获取<code>access_token</code>需要在微信开发者平台-&gt;基本配置中配置<code>IP</code>白名单</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信sdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单实现WebWorker</title>
    <link href="/2022/09/29/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0WebWorker/"/>
    <url>/2022/09/29/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0WebWorker/</url>
    
    <content type="html"><![CDATA[<h3 id="一、独享Web-Worker"><a href="#一、独享Web-Worker" class="headerlink" title="一、独享Web Worker"></a>一、独享Web Worker</h3><ol><li><p>新建<code>worker.js</code>文件</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">onmessage</span> = function(e)&#123;<br>    const <span class="hljs-class"><span class="hljs-keyword">data</span> = e.<span class="hljs-keyword">data</span></span><br>    postMessage(<span class="hljs-class"><span class="hljs-keyword">data</span>.map(<span class="hljs-title">a</span> =&gt; <span class="hljs-title">a</span>*2))</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>主线程<code>main.js</code>中初始化<code>worker</code>实例</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> arr = <span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>]</span><br><span class="hljs-keyword">let</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Worker(&#x27;<span class="hljs-params">worker</span>.<span class="hljs-params">js</span>&#x27;)</span> <span class="hljs-comment">//web worker的url路径必须是同源的</span><br><br>const btn = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">multiple</span>-<span class="hljs-params">btn</span>&#x27;)</span><br>const oldArr = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">old</span>-<span class="hljs-params">arr</span>&#x27;)</span><br>const newArr = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">new</span>-<span class="hljs-params">arr</span>&#x27;)</span><br><br>oldArr.textContent = arr.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span><br><br>btn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;,()</span> =&gt; &#123;<br>    worker.post<span class="hljs-constructor">Message(<span class="hljs-params">arr</span>)</span><br>&#125;)<br><br>worker.onmessage = <span class="hljs-keyword">function</span>(e) &#123;<br>    newArr.textContent = e.data<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编辑<code>html</code>文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>简单实现Web Worker<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;old-arr&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multiple-btn&quot;</span>&gt;</span>点击数字翻倍<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;new-arr&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span> <br></code></pre></td></tr></table></figure></li><li><p>实现效果</p><p><img src="/2022/09/29/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0WebWorker/image-20220926223627267.png" alt="image-20220926223627267"></p></li></ol><h3 id="二、共享Web-Worker"><a href="#二、共享Web-Worker" class="headerlink" title="二、共享Web Worker"></a>二、共享<code>Web Worker</code></h3><ol><li><p>与独享<code>Web Worker</code>区别在于，通过<code>port</code>对象来访问<code>worker</code>实例的方法，独享<code>Web Worker</code>每次都会初始化一个新的<code>worker</code> 实例。新建<code>sharedworker.js</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">onconnect = <span class="hljs-built_in">function</span>(e) &#123;<br>    const port = e<span class="hljs-selector-class">.ports</span><span class="hljs-selector-attr">[0]</span><br>    port<span class="hljs-selector-class">.onmessage</span> = <span class="hljs-built_in">function</span>(e) &#123;<br>        const data = e<span class="hljs-selector-class">.data</span><br>        port<span class="hljs-selector-class">.postMessage</span>(data<span class="hljs-selector-class">.map</span>(<span class="hljs-selector-tag">a</span> =&gt; a*<span class="hljs-number">2</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多个主线程中，均可以通过<code>port</code>对象访问<code>worker</code>实例的方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 初始化shareworker</span><br>let worker = new <span class="hljs-built_in">SharedWorker</span>(<span class="hljs-string">&#x27;shareworker.js&#x27;</span>)<br><br><span class="hljs-comment">// 通过端口访问</span><br>btn<span class="hljs-selector-class">.addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,() =&gt; &#123;<br>    worker<span class="hljs-selector-class">.port</span><span class="hljs-selector-class">.postMessage</span>(arr)<br>&#125;)<br><br>worker<span class="hljs-selector-class">.port</span><span class="hljs-selector-class">.onmessage</span> = <span class="hljs-built_in">function</span>(e) &#123;<br>    newArr<span class="hljs-selector-class">.textContent</span> = e<span class="hljs-selector-class">.data</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><ol><li><code>Web Worker</code>是浏览器内置的<code>API</code>,用于在单独的线程中执行<code>javascript</code>代码，可以用来避免<code>UI</code>阻塞</li><li>线程之间通过<code>message</code>进行通信，消息中的数据都是深拷贝的</li><li><code>Web Worker</code>访问不到<code>window</code>等全局属性，但可以通过<code>XMLHttpRequest || fetch</code>发送请求。它的全局变量指向它本身</li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebWorker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>textContent原来和innerText不同?</title>
    <link href="/2022/09/29/textContent%E5%8E%9F%E6%9D%A5%E5%92%8CinnerText%E4%B8%8D%E5%90%8C?/"/>
    <url>/2022/09/29/textContent%E5%8E%9F%E6%9D%A5%E5%92%8CinnerText%E4%B8%8D%E5%90%8C?/</url>
    
    <content type="html"><![CDATA[<h3 id="一、这些问题的答案是？"><a href="#一、这些问题的答案是？" class="headerlink" title="一、这些问题的答案是？"></a>一、这些问题的答案是？</h3><ol><li><code>position:absolute</code> 是否会改变元素的<code>display</code>计算值？</li><li>访问<code>innerText</code>会触发回流吗？</li></ol><h3 id="二、innerText和textContent究竟有哪些不同？"><a href="#二、innerText和textContent究竟有哪些不同？" class="headerlink" title="二、innerText和textContent究竟有哪些不同？"></a>二、<code>innerText</code>和<code>textContent</code>究竟有哪些不同？</h3><h5 id="1-调用对象"><a href="#1-调用对象" class="headerlink" title="(1) 调用对象"></a>(1) 调用对象</h5><ul><li><code>innerText</code>：<code>HTMLElement</code>，即<code>HTML</code>元素</li><li><code>textContent</code>: Node，即任意<code>Node</code>节点均可以调用，比如<code>script</code>, <code>style</code></li></ul><h5 id="2-值获取规则（IE不符合）"><a href="#2-值获取规则（IE不符合）" class="headerlink" title="(2) 值获取规则（IE不符合）"></a>(2) 值获取规则（IE不符合）</h5><ol><li><p><code>innerText</code></p><ul><li><p>保留块级元素的换行特性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>简单实现Web Worker<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: absolute&quot;</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打印结果：<img src="/2022/09/29/textContent%E5%8E%9F%E6%9D%A5%E5%92%8CinnerText%E4%B8%8D%E5%90%8C?/image-20220929114043356.png" alt="image-20220929114043356"></p><p><em><strong>在这里也可以回答第一个问题</strong></em>：<code>position:absolute</code>会改变元素的<code>display</code>计算值，<code>span</code>元素的<code>display</code>计算值变成了<code>inline-block</code>（关于行内块元素的验证：1. 与其他行内||行内块元素一起占一行；2. 可以设置宽高）</p></li><li><p>不会获取隐藏元素</p><ul><li>也就是说，设置了<code>display:none</code>的元素是获取不到的</li></ul></li><li><p>触发回流</p><ul><li><em><strong>这里也回答了第二个问题</strong></em>：<code>innerText</code>属性值的获取会考虑<code>CSS</code>样式，因此读取该属性值会触发回流以确保计算出的样式是最新的。而回流是会降低性能的</li></ul></li></ul></li><li><p><code>textContent</code></p><ul><li>不保留块级元素的换行特性，只读取纯文本内容</li><li>可以获取隐藏元素</li><li>因为只读取纯文本内容，所以不会触发回流，因此性能是更高的</li></ul></li></ol><h5 id="3-总结"><a href="#3-总结" class="headerlink" title="(3) 总结"></a>(3) 总结</h5><ol><li><p>推荐使用<code>textContent</code>来获取文本内容，性能更高</p></li><li><p>若要兼容<code>IE8</code>(<code>textContent</code> IE9才开始支持)</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">text</span> = dom.textContent || dom.innerText;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pm2本地部署Nuxt项目</title>
    <link href="/2022/08/01/pm2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Nuxt%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/08/01/pm2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Nuxt%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<ol><li><h4 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装<code>pm2</code></h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install pm2@latest -g<br></code></pre></td></tr></table></figure></li><li><h4 id="运行下列指令（不用cd到项目目录下）"><a href="#运行下列指令（不用cd到项目目录下）" class="headerlink" title="运行下列指令（不用cd到项目目录下）"></a>运行下列指令（不用<code>cd</code>到项目目录下）</h4><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">pm2 start npm</span> <span class="hljs-literal">--</span><span class="hljs-comment">name marketing_h5</span>  <span class="hljs-literal">--</span> <span class="hljs-comment">run start</span><br></code></pre></td></tr></table></figure><p>发现项目状态为<code>stopped</code></p><p><img src="/2022/08/01/pm2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Nuxt%E9%A1%B9%E7%9B%AE/image-20220830152831128.png" alt="image-20220830152831128"></p><p>查看报错日志</p><p><img src="/2022/08/01/pm2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Nuxt%E9%A1%B9%E7%9B%AE/image-20220830152907692.png" alt="image-20220830152907692"></p><p>一些博客提到，是由于<code>node</code>无法操作<code>cmd</code>造成的，给出解决方案：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>、<br>npm install <span class="hljs-keyword">node</span><span class="hljs-title">-cmd</span> --save;<br><span class="hljs-number">2</span>、<br>新建startscript.js<br>const <span class="hljs-attr">cmd=</span>require(&#x27;<span class="hljs-keyword">node</span><span class="hljs-title">-cmd</span>&#x27;); <br>cmd.run(&#x27;npm <span class="hljs-literal">start</span>&#x27;);<br><span class="hljs-number">3</span>、<br>启动该脚本<br>pm2 <span class="hljs-literal">start</span> startscript.js<br></code></pre></td></tr></table></figure><p>方案验证有效。通过命令行执行的缺点在于，配置都要在命令行加上，比如<code>--name marketing_h5</code>就是配置了<code>name</code>属性。在<code>Nuxt.js</code>官网找到了<code>pm2</code>启动<code>Nuxt</code>项目的流程</p></li><li><h4 id="NuxtJS-pm2"><a href="#NuxtJS-pm2" class="headerlink" title="NuxtJS-pm2"></a><a href="https://nuxtjs.org/deployments/pm2/"><code>NuxtJS-pm2</code></a></h4><ul><li><h5 id="配置文件在项目根目录新建ecosystem-config-js，添加下列配置"><a href="#配置文件在项目根目录新建ecosystem-config-js，添加下列配置" class="headerlink" title="配置文件在项目根目录新建ecosystem.config.js，添加下列配置"></a>配置文件在项目根目录新建<code>ecosystem.config.js</code>，添加下列配置</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">module.exports = &#123;<br>  apps: [<br>    &#123;<br>      name: <span class="hljs-string">&#x27;NuxtAppName&#x27;</span>,  <span class="hljs-regexp">//</span> 应用程序名称<br>      exec_mode: <span class="hljs-string">&#x27;cluster&#x27;</span>,<br>      instances: <span class="hljs-string">&#x27;max&#x27;</span>, <span class="hljs-regexp">//</span> Or a number of instances  启动实例数量，可以配置为<span class="hljs-number">1</span><br>      script: <span class="hljs-string">&#x27;./node_modules/nuxt/bin/nuxt.js&#x27;</span>,   <span class="hljs-regexp">//</span>pm2 start 执行的脚本相对路径<br>      args: <span class="hljs-string">&#x27;start&#x27;</span>   <span class="hljs-regexp">//</span> 传递给脚本的参数<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>配置可参考<ul><li>中文： <a href="https://blog.csdn.net/zz00008888/article/details/113738025"><code>ecosystem.config.js字段详细介绍</code></a></li><li>英文：<a href="https://pm2.keymetrics.io/docs/usage/application-declaration/#general"><code>Attributes available</code></a></li></ul></li></ul></li><li><h5 id="依次执行："><a href="#依次执行：" class="headerlink" title="依次执行："></a>依次执行：</h5><ul><li><p><code>npm run build</code></p></li><li><p><code>pm2 start</code>：实际上是会去找配置文件。如果所在目录没有配置文件</p><p><img src="/2022/08/01/pm2%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Nuxt%E9%A1%B9%E7%9B%AE/image-20220830152940864.png" alt="image-20220830152940864"></p></li><li><p><code>pm2 ls</code></p></li></ul></li><li><h5 id="配置log时间显示"><a href="#配置log时间显示" class="headerlink" title="配置log时间显示"></a>配置<code>log</code>时间显示</h5><ul><li><p>在博客中看到配置<code>time: true</code>后日志有时间显示，本地验证设置<code>time:true</code>或执行<code>pm2 start npm --name marketing_h5 --time -- run star</code>后日志可以显示时间，但官方文档中未找到，按照官方文档给的字段</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">module.exports = &#123;<br>    apps: [<br>      &#123;<br>        name: <span class="hljs-string">&#x27;marketing_h5&#x27;</span>,<br>        exec_mode: <span class="hljs-string">&#x27;cluster&#x27;</span>,<br>        instances: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-regexp">//</span> Or a number of instances<br>        script: <span class="hljs-string">&#x27;./node_modules/nuxt/bin/nuxt.js&#x27;</span>,<br>        args: <span class="hljs-string">&#x27;start&#x27;</span>,<br>        log_date_format: <span class="hljs-string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>,   <span class="hljs-regexp">//</span> 配置日志日期格式<br>      &#125; <br>    ]<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><h4 id="修改pm2启动端口"><a href="#修改pm2启动端口" class="headerlink" title="修改pm2启动端口"></a>修改<code>pm2</code>启动端口</h4><ul><li><p>我们一般会在<code>package.json</code>中配置<code>nuxt</code>项目启动端口</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// 与`script`同级<br><span class="hljs-string">&quot;config&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;nuxt&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br>      <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;3008&quot;</span><br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>但是通过<code>pm2</code>启动的时候端口号依旧是<code>3000</code>，经过各种方案尝试，最终通过以下方案实现：</p><p>在<code>nuxt.config.js</code>中，与<code>head</code>同级添加以下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span> &#123;<br>    <span class="hljs-attr">port:</span> <span class="hljs-number">3008</span>,<br>    <span class="hljs-attr">host:</span> <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,<br> &#125;<span class="hljs-string">,</span><br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解Vue插槽相关知识点</title>
    <link href="/2022/07/19/%E7%90%86%E8%A7%A3Vue%E6%8F%92%E6%A7%BD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/07/19/%E7%90%86%E8%A7%A3Vue%E6%8F%92%E6%A7%BD%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="1-背景"><a href="#1-背景" class="headerlink" title="(1) 背景"></a>(1) 背景</h4><p>​在使用<code>element-ui</code>的表格组件时，看到对<code>slot-scope</code>的使用，当下不是很明白，于是先对插槽这块知识进行了补齐</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-table</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;tableData&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;250&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;日期&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;120&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">scope.row.date</span> &#125;&#125;</span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">el-table</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-插槽相关知识点"><a href="#2-插槽相关知识点" class="headerlink" title="(2) 插槽相关知识点"></a>(2) 插槽相关知识点</h4><p>​需要注意的是，自<code>Vue 2.6.0</code>引入<code>v-slot</code>指令，<code>slot</code>和<code>slot-scope</code> <code>attribute</code>已被官方废弃，但在<code>Vue2.x</code>版本中仍被支持</p><ol><li><h5 id="插槽内容："><a href="#插槽内容：" class="headerlink" title="插槽内容："></a>插槽内容：</h5><ul><li>在子组件<code>child</code>中的<code>template</code>中包含一个<code>&lt;slot&gt;</code>元素，则父组件<code>parent</code>在调用<code>child</code>时放在<code>child</code>起始和结束标签之间(<code>&lt;child&gt;内容&lt;/child&gt;</code>)的内容，会在<code>child</code>渲染时替换<code>&lt;slot&gt;&lt;/slot&gt;</code>；反之，若<code>child</code>中的<code>template</code>不包含<code>&lt;slot&gt;</code>元素，则上述<strong>“内容”</strong>会被全部抛弃</li></ul></li><li><h5 id="编译作用域："><a href="#编译作用域：" class="headerlink" title="编译作用域："></a>编译作用域：</h5><ul><li><p>父级模板里的所有内容都是在父级作用域中编译的；子级模板中的所有内容都是在子作用域中编译的</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="language-xml">  Clicking here will send you to: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">url</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-comment">&lt;!--</span></span><br><span class="hljs-comment"><span class="language-xml">  这里的 `url` 会是 undefined，因为其 (指该插槽的) 内容是</span></span><br><span class="hljs-comment"><span class="language-xml">  _传递给_ &lt;navigation-link&gt; 的而不是</span></span><br><span class="hljs-comment"><span class="language-xml">  在 &lt;navigation-link&gt; 组件*内部*定义的。</span></span><br><span class="hljs-comment"><span class="language-xml">  --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><h5 id="作用域插槽："><a href="#作用域插槽：" class="headerlink" title="作用域插槽："></a>作用域插槽：</h5><ul><li><p>在<code>child</code>中的<code>&lt;slot&gt;</code>元素上绑定<code>attribute</code>(插槽<code>prop</code>)，在<code>parent</code>组件中可以使用带值的<code>v-slot</code>来接收插槽<code>prop</code>，从而使得插槽内容可以访问子组件中才有的数据。其内部工作原理：将插槽内容包裹在一个拥有单个参数的函数里</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-params">(slotProps)</span> &#123;<br>  <span class="hljs-comment">// 插槽内容</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>用法1</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">// child子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  // user.lastName作为后备内容，插槽设置未提供内容时会被渲染</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>  <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.lastName</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>   </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><ul><li><p>可以将包含所有插槽<code>prop</code>的对象命名为任意名字，例如<code>slotProps</code></p></li><li><p><code>&lt;slot&gt;</code>元素可以通过<code>name </code>  <code>attribute</code>来实现具名插槽，一个不带<code>name</code>的<code>&lt;slot&gt;</code>出口会带有隐含的名字<code>defalut</code>。当被提供的内容<strong>只有</strong>默认插槽时，可简写为</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="language-xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">// 或</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">v-slot</span> =<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="language-xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">slotProps.user.firstName</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>只要出现多个插槽，所有插槽都应使用完整的基于<code>&lt;template&gt;</code>的语法</p></li></ul></li><li><p>用法2：解构</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><br><span class="language-xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">//  也可以重命名</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;&#123; user:person &#125;&quot;</span>&gt;</span></span><br><span class="language-xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">// 还可以定义后备内容，针对插槽prop是undefined的情况</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;&#123; user = &#123;firstName: &#x27;Guest&#x27;&#125;&#125;&quot;</span>&gt;</span></span><br><span class="language-xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.firstName</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><h4 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">dynamicSlotName</span>]&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><h4 id="具名插槽缩写"><a href="#具名插槽缩写" class="headerlink" title="具名插槽缩写"></a>具名插槽缩写</h4><ul><li>可以把参数之前的所有内容(即<strong>只有在有参数时才可用</strong>) – <code>v-slot:</code>替换为字符<code>#</code>：例如<code>v-slot:header</code>可以被重写为<code>#header</code></li></ul></li></ol><h4 id="6-关于el-table实现"><a href="#6-关于el-table实现" class="headerlink" title="(6) 关于el-table实现"></a>(6) 关于<code>el-table</code>实现</h4><ol><li><p><code>element-ui</code>文档解释：：<code>Table-column Scoped Slot</code>自定义列的内容，参数为 <code>&#123; row, column, $index &#125;</code>(<code>name</code>属性未定义情况下)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">slot-scope=<span class="hljs-string">&quot;scope&quot;</span>  <span class="hljs-regexp">//</span>获取当前单元格<br>scope.<span class="hljs-variable">$index</span>  <span class="hljs-regexp">//</span> 拿到当前行的index<br>scope.row  <span class="hljs-regexp">//</span> 拿到当前行的数据对象<br>scope.row.date  <span class="hljs-regexp">//</span> 当前行数据对象中date属性的值<br></code></pre></td></tr></table></figure></li><li><p>对于<code>el-table</code>源码中的这个<code>this.$scopedSlots</code>属性，似乎与插槽作用域不是同一个东西？后面再仔细看看源码了解</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FormData实现本地文件上传</title>
    <link href="/2022/07/18/FormData%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <url>/2022/07/18/FormData%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="1-问题"><a href="#1-问题" class="headerlink" title="(1) 问题"></a>(1) 问题</h4><p>​<code>js</code>如何实现简单的本地文件上传？</p><h4 id="2-FormData概念补充"><a href="#2-FormData概念补充" class="headerlink" title="(2) FormData概念补充"></a>(2) <code>FormData</code>概念补充</h4><ol><li><code>FormData</code>提供了一种表示表单数据的键值对<code>key/value</code>的构造方式，并且可以轻松的通过<code>XMLHttpRequest.send()</code>的方式发送出去</li><li>实现了<code>FormData</code>接口的对象可以直接在<code>for...of</code>结构中使用，而不需要调用<code>entries()</code></li><li><strong>此特性可用于<code>Web Workers</code></strong></li><li><code>FormData</code>对象的方法，参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData">FormData</a></li><li><code>FormData()</code>构造函数用于创建一个新的<code>FormData</code>对象<ul><li>可选参数<code>form</code>: <code>var formData = new FormData(form)</code>，当指定<code>form</code>参数时，创建的<code>FormData</code>对象会自动将<code>form</code>中的表单值也包含进去，包括文件内容也会被编码之后包含进去</li></ul></li></ol><h4 id="3-Web-Workers概念补充"><a href="#3-Web-Workers概念补充" class="headerlink" title="(3) Web Workers概念补充"></a>(3) <code>Web Workers</code>概念补充</h4><ol><li><code>Web Workers</code>可以实现在独立于<code>Web</code>应用程序主执行线程的后台线程中运行脚本，从而可以将一些任务交给非主线程的其他独立线程去做，而不会阻塞&#x2F;减慢主线程(通常是<code>UI</code>)运行</li><li><code>worker</code>是使用构造函数(例如<code>Worker()</code>)创建的对象，在该对象中会运行一个命名的<code>javascript</code>文件</li><li>工作线程和主线程之间的数据发送通过消息系统来实现：双方都使用<code>postMessage()</code>方法发送消息；通过<code>onmessage</code>事件处理程序来响应消息(消息包含在<code>Message</code>事件的<code>data</code>属性中)。<strong>数据是复制的而不是共享的</strong></li></ol><h4 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="(4) 解决方案"></a>(4) 解决方案</h4><ol><li><p><code>input</code>框的<code>type = file</code>时，即可选择本地文件</p></li><li><p><code>FormData</code>对象的使用：</p><ul><li><p>将<code>form</code>中所有表单元素的<code>name</code>和<code>value</code>组装成一个<code>queryString</code>(查询字符串？)。<code>FormData</code>对象的操作方法，全部在原型中，自己本身没有任何的属性及方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData()<br>formData.append(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;zhang&#x27;</span>)<br>formData.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;user&#x27;</span>)  <span class="hljs-comment">// zhang</span><br></code></pre></td></tr></table></figure></li><li><p>异步上传二进制数据</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">form</span> action=<span class="hljs-string">&quot;&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">label</span> <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;<br>        文件：&lt;<span class="hljs-keyword">input</span> id=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span>&gt;<br>    &lt;/<span class="hljs-keyword">label</span>&gt;<br>    &lt;<span class="hljs-keyword">label</span> <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;保存&quot;</span>&gt;<br>    &lt;/<span class="hljs-keyword">label</span>&gt;<br>&lt;/<span class="hljs-keyword">form</span>&gt;<br><br><br><span class="hljs-keyword">var</span> btn  = document.querySelector(&#x27;[<span class="hljs-keyword">type</span> = button]&#x27;);<br>btn.onclick = function() &#123;<br><span class="hljs-comment">// 文件元素</span><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">file</span> = document.querySelector(&#x27;[<span class="hljs-keyword">type</span> = <span class="hljs-keyword">file</span>]&#x27;);<br><span class="hljs-comment">// 通过FormData将文件转成二进制数据</span><br><span class="hljs-keyword">var</span> formData = new FormData();<br>formData.<span class="hljs-keyword">append</span>(&#x27;upload&#x27;, <span class="hljs-keyword">file</span>.flies[0]);<br><span class="hljs-keyword">var</span> xhr = new XMLHttpRequest();<br>    <br>xhr.<span class="hljs-keyword">open</span>(&#x27;<span class="hljs-keyword">post</span>&#x27;,&#x27;<span class="hljs-keyword">file</span>.php&#x27;);  <span class="hljs-comment">// action = file.php</span><br><span class="hljs-comment">// 监听上传进度</span><br>xhr.upload.onprogress = function(ev) &#123;<br><span class="hljs-keyword">var</span> percent  = (ev.loaded / ev.<span class="hljs-keyword">total</span>) * 100 + &#x27;%&#x27; <span class="hljs-comment">// ev为事件对象</span><br>progress.style.width = percent;<br>&#125;<br>xhr.send(formData);<br>xhr.onreadystatechange = function()&#123;<br>        <span class="hljs-keyword">if</span>(xhr.readyState == 4)&#123;<br>            <span class="hljs-keyword">if</span>(xhr.status == 200)&#123;<br>                <span class="hljs-comment">//实际操作</span><br>            &#125;<br>        &#125;<br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>el-upload</code>搭配<code>FormData</code>实现自定义上传：</p><ul><li><p>通过<code>httpRequest</code>属性进行自定义上传，默认参数对象<code>param</code>的属性包括</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">action</span>, <span class="hljs-keyword">data</span>, <span class="hljs-keyword">file</span>(即要上传的文件),filename, headers, onError, onProgress, onSuccess, withCredentials<br></code></pre></td></tr></table></figure></li><li><p>定义自定义上传方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">uploadHttpRequest</span>(<span class="hljs-params">param</span>) &#123;<br>  <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();<br>  formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;file&quot;</span>, param.<span class="hljs-property">file</span>); <span class="hljs-comment">// 添加文件对象</span><br>  <span class="hljs-title function_">importList</span>(formData)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> === <span class="hljs-number">200</span>) &#123;<br>        param.<span class="hljs-title function_">onSuccess</span>(); <span class="hljs-comment">// 上传成功的文件显示绿色的对勾</span><br>        <span class="hljs-variable language_">this</span>.$message(&#123;<br>          <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;导入成功！&quot;</span>,<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>        &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> errData = res.<span class="hljs-property">data</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">errData</span> = errData;<br>        <span class="hljs-variable language_">this</span>.$message(&#123;<br>          <span class="hljs-attr">showClose</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">message</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">errData</span>,<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>        &#125;);<br>      &#125;<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败&quot;</span>, err);<br>      param.<span class="hljs-title function_">onError</span>(); <span class="hljs-comment">// 上传失败的文件会从文件列表中删除</span><br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端落地页适配-小车地图移动</title>
    <link href="/2022/07/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%90%BD%E5%9C%B0%E9%A1%B5%E9%80%82%E9%85%8D-%E5%B0%8F%E8%BD%A6%E5%9C%B0%E5%9B%BE%E7%A7%BB%E5%8A%A8/"/>
    <url>/2022/07/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%90%BD%E5%9C%B0%E9%A1%B5%E9%80%82%E9%85%8D-%E5%B0%8F%E8%BD%A6%E5%9C%B0%E5%9B%BE%E7%A7%BB%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><p>​小车在地图上不断前进，每走到一个标记点，停下。地图原始比例为：宽1080 高1920</p><h4 id="1-问题"><a href="#1-问题" class="headerlink" title="(1) 问题"></a>(1) 问题</h4><ol><li><p>移动端适配，保证不同手机屏幕上地图比例不变</p></li><li><p>设置样式时，涉及到单位的地方要进行换算：<code>px -&gt; vh/vw</code></p></li><li><p>不同移动端，小车起始位置像素可能不一致，需要动态设置动画</p></li><li><p>实现小车的精准移动</p></li><li><p>实现小车的停止和前进</p></li><li><p>实现小车镜像翻转，镜像翻转无法通过以下动画实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> trans180 &#123;<br>    <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">0deg</span>);<br>    &#125;<br><br>    <span class="hljs-number">100%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="(2) 解决方案"></a>(2) 解决方案</h4><ol><li><h5 id="针对问题一：以地图原始比例的宽或高作为基准，将像素px换算成单位vh-vw"><a href="#针对问题一：以地图原始比例的宽或高作为基准，将像素px换算成单位vh-vw" class="headerlink" title="针对问题一：以地图原始比例的宽或高作为基准，将像素px换算成单位vh/vw"></a>针对问题一：以地图原始比例的宽或高作为基准，将像素<code>px</code>换算成单位<code>vh/vw</code></h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> ((mediaW / mediaH) &gt; (<span class="hljs-number">1080</span> / <span class="hljs-number">1920</span>)) &#123;<br>    <span class="hljs-keyword">var</span> perVh = <span class="hljs-number">1920</span> / <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">var</span> position = Math.<span class="hljs-built_in">round</span>(<span class="hljs-built_in">number</span> / perVh, <span class="hljs-number">4</span>) + <span class="hljs-string">&#x27;vh&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> perVw =<span class="hljs-number">1080</span> / <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">var</span> position = Math.<span class="hljs-built_in">round</span>(<span class="hljs-built_in">number</span> / perVw, <span class="hljs-number">4</span>) + <span class="hljs-string">&#x27;vw&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>原理：<code>mediaW</code>和 <code>mediaH</code>分别为手机显示窗口的宽高。若手机宽高比&gt;地图宽高比，说明在地图高度占满全屏的情况下，宽度不能占满，此时则以地图高为基准，整屏高是<code>100vh</code>，将设计图上的<code>px</code>均换算为<code>vh</code>作为单位来表示；反之则以地图宽度为基准，整屏宽为<code>100vw</code>，将设计图上的<code>px</code>均换算为<code>vw</code>作为单位来表示；同时保持地图始终居中</p></li><li><h5 id="针对问题2：定义单位换算的函数，通过js操作DOM动态设置宽高以及相对位置"><a href="#针对问题2：定义单位换算的函数，通过js操作DOM动态设置宽高以及相对位置" class="headerlink" title="针对问题2：定义单位换算的函数，通过js操作DOM动态设置宽高以及相对位置"></a>针对问题2：定义单位换算的函数，通过<code>js</code>操作<code>DOM</code>动态设置宽高以及相对位置</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-string">&quot;.title&quot;</span>)</span>.css(&#123; <span class="hljs-string">&quot;width&quot;</span>: compute<span class="hljs-constructor">PX(790)</span>, <span class="hljs-string">&quot;top&quot;</span>: compute<span class="hljs-constructor">PX(80)</span>, <span class="hljs-string">&quot;left&quot;</span>: compute<span class="hljs-constructor">PX(50)</span> &#125;)<br></code></pre></td></tr></table></figure></li><li><h5 id="针对问题3：通过style-insertRule动态设置动画"><a href="#针对问题3：通过style-insertRule动态设置动画" class="headerlink" title="针对问题3：通过style.insertRule动态设置动画"></a>针对问题3：通过<code>style.insertRule</code>动态设置动画</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">style<span class="hljs-selector-class">.insertRule</span>(`<span class="hljs-keyword">@keyframes</span> moveToMarkR$&#123;cur&#125;&#123;<span class="hljs-number">0%</span>&#123;<span class="hljs-attribute">left</span>:$&#123;currentX&#125;;<span class="hljs-attribute">top</span>:$&#123;currentY&#125;;&#125;<span class="hljs-number">100%</span> &#123;<span class="hljs-attribute">left</span>:$&#123;moveCalc(currentX, <span class="hljs-number">252</span>)&#125;; <span class="hljs-attribute">top</span>:$&#123;currentY&#125;;&#125;&#125;`)<br></code></pre></td></tr></table></figure></li><li><h5 id="针对问题4：每一步动画都是在上一步基础上，加上地图上的移动距离（经过单位换算之后，单位为vh-x2F-vw），通过jQuery的-css-或-offset-方法所获取到当前位置，所得值为vh-vw转换之后的实际像素值，无法直接与移动距离相加"><a href="#针对问题4：每一步动画都是在上一步基础上，加上地图上的移动距离（经过单位换算之后，单位为vh-x2F-vw），通过jQuery的-css-或-offset-方法所获取到当前位置，所得值为vh-vw转换之后的实际像素值，无法直接与移动距离相加" class="headerlink" title="针对问题4：每一步动画都是在上一步基础上，加上地图上的移动距离（经过单位换算之后，单位为vh&#x2F;vw），通过jQuery的.css()或.offset()方法所获取到当前位置，所得值为vh/vw转换之后的实际像素值，无法直接与移动距离相加"></a>针对问题4：每一步动画都是在上一步基础上，加上地图上的<strong>移动距离</strong>（经过单位换算之后，单位为<code>vh</code>&#x2F;<code>vw</code>），通过<code>jQuery</code>的<code>.css()</code>或<code>.offset()</code>方法所获取到当前位置，所得值为<code>vh/vw</code>转换之后的实际像素值，无法直接与<strong>移动距离</strong>相加</h5><ul><li><p>先将实际像素值转换为<code>vh/vw</code>单位</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> ((mediaW / mediaH) &gt; (<span class="hljs-number">1080</span> / <span class="hljs-number">1920</span>)) &#123;<br>    <span class="hljs-keyword">var</span> perVh = mediaH / <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">var</span> position = Math.<span class="hljs-built_in">round</span>(<span class="hljs-built_in">number</span> / perVh, <span class="hljs-number">4</span>) + <span class="hljs-string">&#x27;vh&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> perVw = mediaW / <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">var</span> position = Math.<span class="hljs-built_in">round</span>(<span class="hljs-built_in">number</span> / perVw, <span class="hljs-number">4</span>) + <span class="hljs-string">&#x27;vw&#x27;</span><br>&#125;<br><span class="hljs-keyword">return</span> position;<br></code></pre></td></tr></table></figure><p>原理：假如自适应是以<code>vh</code>作为单位，通过当前屏幕的宽度像素，除以100即可得出每<code>vh</code>实际像素是多少，下一步即可通过实际像素换算成对应的<code>vh</code></p></li><li><p>对<strong>移动距离</strong>进行换算</p><ul><li>若以<code>vh</code>作为单位时，因为地图宽度并未撑满全屏，所以不能直接用换算公式进行换算。需要算出1080为多少<code>vh</code>，然后乘以比例<code>移动距离/1080</code></li><li>若以<code>vw</code>作为单位，直接用公式进行换算即可</li></ul></li></ul></li><li><h4 id="针对问题5："><a href="#针对问题5：" class="headerlink" title="针对问题5："></a>针对问题5：</h4><ul><li><p><code>step1</code>：将地图分为多个点，在不同的点分别添加动画：向右&#x2F;左直走至下一个标记、向右&#x2F;左直走至拐角、向下、镜像旋转</p></li><li><p><code>step2</code>：监听动画结束事件<code>webkitAnimationEnd</code>，异步调用回调函数，回调函数执行完，成功回传参数后，执行添加下一个动画的操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> imple<span class="hljs-constructor">Animation(<span class="hljs-params">count</span>)</span> &#123;<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> =&gt; &#123;<br>        show<span class="hljs-constructor">Question(<span class="hljs-params">count</span>, <span class="hljs-params">resolve</span>)</span>   <span class="hljs-comment">// showQuestion第二个参数(resolve)执行时，该Promise对象即可执行.then操作，根据回传参数进行下一步操作</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>针对问题6：先执行<code>transform</code>进行翻转，再执行动画</p><ul><li><p>向左镜像翻转</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">先执行以下<span class="hljs-attribute">transform</span>，<br>car<span class="hljs-selector-class">.css</span>(&quot;<span class="hljs-attribute">transform</span>&quot;, &quot;rotateY(<span class="hljs-number">180deg</span>)&quot;)<br><br>再执行动画<br><span class="hljs-keyword">@keyframes</span> trans180 &#123;<br>    <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">0deg</span>);<br>    &#125;<br><br>    <span class="hljs-number">100%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>向右镜像翻转</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">先执行以下<span class="hljs-attribute">transform</span>，<br>car<span class="hljs-selector-class">.css</span>(&quot;<span class="hljs-attribute">transform</span>&quot;, &quot;rotateY(<span class="hljs-number">0deg</span>)&quot;)<br><br>再执行动画<br><span class="hljs-keyword">@keyframes</span> transMinus180 &#123;<br>    <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>);<br>    &#125;<br><br>    <span class="hljs-number">100%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">0deg</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>实践输出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用flex布局和nth-child的注意问题</title>
    <link href="/2022/07/17/%E4%BD%BF%E7%94%A8flex%E5%B8%83%E5%B1%80%E5%92%8Cnth-child%E7%9A%84%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/17/%E4%BD%BF%E7%94%A8flex%E5%B8%83%E5%B1%80%E5%92%8Cnth-child%E7%9A%84%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1-问题"><a href="#1-问题" class="headerlink" title="(1) 问题"></a>(1) 问题</h4><ol><li>用flex布局时，左边图片右边文字，给图片盒子设置了宽度，但渲染后图片盒子宽度缩小了，且宽度是不固定的</li><li><code>ul</code>盒子包裹一个<code>img</code>标签和多个<code>li</code>标签，使用<code>nth-child(1)</code>设置第一个<code>li</code>标签样式无效</li></ol><h4 id="2-解决"><a href="#2-解决" class="headerlink" title="(2) 解决"></a>(2) 解决</h4><ol><li><p>针对问题一：使用flex布局时，多个盒子都要设置宽度</p></li><li><p>针对问题二：注意<code>nth-child(n)</code>和<code>nth-of-type(n)</code>的区别</p><ul><li><p><code>nth-child(n)</code>: 找到当前元素的所有兄弟元素，用<code>n</code>来筛选出在当前元素的兄弟元素节点的位置。</p><ul><li><p><code>p:nth-child(2)</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">p</span>&gt;第一个&lt;/<span class="hljs-selector-tag">p</span>&gt;<br>&lt;<span class="hljs-selector-tag">h1</span>&gt;<span class="hljs-selector-tag">h1</span>标题&lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>&lt;<span class="hljs-selector-tag">p</span>&gt;第二个&lt;/<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>p:nth-child(2)</code>:可以理解为匹配属于<code>p</code>父元素的第二个子元素的所有<code>p</code>。但第二个兄弟节点是<code>&lt;h1&gt;</code>元素，所以取不到<code>p:nth-child(2)</code>。具体过程可以理解为：</p><ul><li>找到<code>p</code>父元素下所有的子元素</li><li>找到第二个元素</li><li>匹配标签选择器<code>p</code>，若匹配到了则选中</li></ul></li></ul></li><li><p><code>nth-of-type(n)</code>：针对具有一组兄弟节点的标签，用<code>n</code>来筛选出在一组兄弟节点中的位置</p><ul><li><p><code>p:nth-of-type(2)</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">p</span>&gt;第一个&lt;/<span class="hljs-selector-tag">p</span>&gt;<br>&lt;<span class="hljs-selector-tag">h1</span>&gt;<span class="hljs-selector-tag">h1</span>标题&lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>&lt;<span class="hljs-selector-tag">p</span>&gt;第二个&lt;/<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>p:nth-of-type(2)</code>:可以理解为匹配属于<code>p</code>父元素的第二个<code>p</code>的每个<code>p</code>。所以会选中<code>&lt;p&gt;第二个&lt;/p&gt;</code>。具体过程可以理解为：</p><ul><li><p>找到<code>p</code>父元素下所有的子元素</p></li><li><p>按标签名找到分组：</p><ul><li><p><code>p</code>标签组</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>第一个<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>第二个<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>找到第<code>2</code>个元素，若找到则选中</p></li></ul></li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>实践输出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2中修改vant-ui样式无效</title>
    <link href="/2022/07/17/Vue2%E4%B8%AD%E4%BF%AE%E6%94%B9vant-ui%E6%A0%B7%E5%BC%8F%E6%97%A0%E6%95%88/"/>
    <url>/2022/07/17/Vue2%E4%B8%AD%E4%BF%AE%E6%94%B9vant-ui%E6%A0%B7%E5%BC%8F%E6%97%A0%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h4 id="1-问题："><a href="#1-问题：" class="headerlink" title="(1) 问题："></a>(1) 问题：</h4><p>​<code>Vue2</code>中使用<code>vant ui</code>(版本<code>2.12.26</code>)时，想修改样式但无效</p><h4 id="（2）解决办法："><a href="#（2）解决办法：" class="headerlink" title="（2）解决办法："></a>（2）解决办法：</h4><ol><li>尝试在<code>.vue</code>文件里直接修改(<code>lang=&quot;less&quot; scoped</code>)， 无效</li><li>尝试加<code>v-deep</code>  或 <code>/deep/</code>， 无效</li><li>尝试全局建一个<code>resetvant.less</code>，并在<code>main.js</code>中引入，无效</li><li><strong>最终解决</strong>：全局建<code>resetvant.css</code>文件，并在<code>main.js</code>中引入,，生效</li></ol>]]></content>
    
    
    <categories>
      
      <category>实践输出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>首屏加载hover切换图片延迟</title>
    <link href="/2022/07/15/%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BDhover%E5%88%87%E6%8D%A2%E5%9B%BE%E7%89%87%E5%BB%B6%E8%BF%9F/"/>
    <url>/2022/07/15/%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BDhover%E5%88%87%E6%8D%A2%E5%9B%BE%E7%89%87%E5%BB%B6%E8%BF%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="1-问题"><a href="#1-问题" class="headerlink" title="(1) 问题"></a>(1) 问题</h4><p>想在<code>hover</code>的时候切换<code>img</code>标签的<code>url</code>，但首屏加载时之后进行hover操作时，总会出现一些延迟，怀疑是网络请求加载导致</p><h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="(2) 解决方案"></a>(2) 解决方案</h4><ol><li><p>通过图片预先请求来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">preload</span>(); <br>&#125;,<br><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">preload</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> preLoadList = [<br>        url1,<br>        url2,<br>        ...<br>      ];<br>      preLoadList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">img</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>        image.<span class="hljs-property">src</span> = img;<br>        image.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;加载成功&quot;</span>);<br>        &#125;;<br>      &#125;);<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>隐藏未选中图片</p><p>同时加载需要进行切换的几张图片，隐藏非默认展示的图片。隐藏元素的几种操作方式的区别</p><ul><li><code>display:none</code><ul><li>隐藏之后不占位置</li><li>不会被子元素继承，父元素不存在，子元素也不会显示出</li><li>无法触发元素的绑定事件</li><li><code>transition</code>无效</li></ul></li><li><code>visibility: hidden</code><ul><li>隐藏之后占据位置</li><li>会被子元素继承，通过设置子元素<code>visibility:visible</code>来显示子元素</li><li>无法触发元素的绑定事件</li><li><code>transition</code>无效</li></ul></li><li><code>opacity: 0</code><ul><li>隐藏之后占据位置</li><li>会被子元素继承，但<strong>无法</strong>通过设置子元素<code>opacity:0</code>来重新显示</li><li>可以触发元素的绑定事件</li><li><code>transition</code>有效</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>实践输出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2.x数据驱动</title>
    <link href="/2022/07/15/Vue2-x%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/"/>
    <url>/2022/07/15/Vue2-x%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="1-new-Vue之后发生了什么？"><a href="#1-new-Vue之后发生了什么？" class="headerlink" title="(1) new Vue之后发生了什么？"></a>(1) <code>new Vue</code>之后发生了什么？</h4><ol><li>定位到采用<code>Function</code>实现的<code>Vue</code>类，主要逻辑是调用了<code>this._init()</code>方法进行初始化</li><li><code>_init()</code>方法主要实现了：<ul><li>合并配置、初始化生命周期、初始化事件中心、初始化渲染、初始化<code>data props computed watcher</code>等等</li></ul></li></ol><h4 id="2-Vue挂载"><a href="#2-Vue挂载" class="headerlink" title="(2) Vue挂载"></a>(2)<code> Vue</code>挂载</h4><ol><li><code>compiler</code>版本的<code>Vuejs</code>：先对原来原型上的<code>$mount</code>进行一个扩展(添加一个在线编译的过程)，然后调用原来原型上的<code>$mount</code>进行挂载</li><li><code>$mount</code>的实现主要是调用<code>mountComponent</code>方法，该函数主要逻辑：<ul><li>实例化一个<code>Watcher</code>， 其回调函数会调用<code>updateComponent</code>方法</li><li>实现<code>updateComponent</code>主要逻辑<ul><li>调用<code>vm._render()</code>生成<code>VNode</code></li><li>调用<code>vm._update()</code>更新<code>DOM</code></li></ul></li><li>判断实例是否已挂载</li></ul></li></ol><h4 id="3-render"><a href="#3-render" class="headerlink" title="(3)render"></a>(3)<code>render</code></h4><ol><li><p><code>vm._render</code>的主要逻辑是调用<code>render</code>函数（(1) 为用户手写的<code>render</code>函数，或者(2) 在扩展的<code>$mount</code>中，由<code>el</code>或<code>template</code>转换成的<code>render</code>函数。<code>render</code>函数通过<code>vm.$options</code>访问），参数为<code>vm.$createElement</code></p><ul><li><p><code>vm.$createElement</code>主要逻辑是调用<code>createElement</code>方法，值得注意的是</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 被模板编译成的render函数使用</span><br>vm._c =<span class="hljs-function"> (<span class="hljs-params">a</span>, <span class="hljs-params">b</span>, <span class="hljs-params">c</span>, <span class="hljs-params">d</span>) =&gt;</span> create<span class="hljs-constructor">Element(<span class="hljs-params">vm</span>, <span class="hljs-params">a</span>, <span class="hljs-params">b</span>, <span class="hljs-params">c</span>, <span class="hljs-params">d</span>, <span class="hljs-params">false</span>)</span><br><br><span class="hljs-comment">// 被用户手写的render函数使用</span><br>vm.$createElement =<span class="hljs-function"> (<span class="hljs-params">a</span>, <span class="hljs-params">b</span>, <span class="hljs-params">c</span>, <span class="hljs-params">d</span>) =&gt;</span> create<span class="hljs-constructor">Element(<span class="hljs-params">vm</span>, <span class="hljs-params">a</span>, <span class="hljs-params">b</span>, <span class="hljs-params">c</span>, <span class="hljs-params">d</span>, <span class="hljs-params">true</span>)</span><br></code></pre></td></tr></table></figure><p><strong>疑问：为什么没有调用<code>vm._c</code>?</strong></p></li></ul></li><li><p><code>createElement</code>创建<code>VNode</code>的过程主要包括</p><ul><li>规范化当前<code>VNode</code>的子节点<code>children</code>，将其变为一个类型为<code>VNode</code>的<code>Array</code>。每个<code>VNode</code>有<code>children</code>，<code>children</code>中每个元素也是一个<code>VNode</code>，这样就形成了一个<code>VNode Tree</code></li><li>根据当前<code>tag</code>类型，实例化一个普通<code>VNode</code>节点，或调用<code>createComponent</code>方法创建一个组件<code>VNode</code></li></ul></li><li><p>总结</p><ul><li><code>vm._render</code>最终通过执行<code>createElement</code>方法返回<code>vnode</code></li></ul></li></ol><h4 id="4-update"><a href="#4-update" class="headerlink" title="(4) update"></a>(4) <code>update</code></h4><ol><li><code>vm._update</code>的主要逻辑是调用<code>vm._patch_</code>方法(分为初次渲染和更新两种情况)</li><li><code>vm._patch_</code>的最终实现逻辑：<ul><li>递归的调用<code>createElm</code>方法生成<code>vnode</code>队列，调用原生<code>DOM</code>的<code>API</code>将<code>DOM</code>插入到父节点中（以上是<code>createElm</code>的函数逻辑）</li><li>由于是递归调用，所以整个<code>vnode</code>树节点的插入顺序是先子后父</li></ul></li></ol><h4 id="5-Virtual-DOM"><a href="#5-Virtual-DOM" class="headerlink" title="(5) Virtual DOM"></a>(5) <code>Virtual DOM</code></h4><ol><li><code>Virtual DOM</code>就是用一个原生的<code>js</code>对象去描述一个<code>DOM</code>节点，在<code>Vue</code>中是通过<code>VNode</code>这个<code>Class</code>去描述</li><li><code>VNode</code>只是用来映射到真实<code>DOM</code>的渲染，不包含操作<code>DOM</code>的方法。核心定义为关键属性、标签名、数据、子节点、键值等</li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>父组件异步获取到的数据如何同步到子组件</title>
    <link href="/2022/07/14/%E7%88%B6%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/07/14/%E7%88%B6%E7%BB%84%E4%BB%B6%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="1-父子组件生命周期执行顺序"><a href="#1-父子组件生命周期执行顺序" class="headerlink" title="(1) 父子组件生命周期执行顺序"></a>(1) 父子组件生命周期执行顺序</h4><ol><li><p>加载渲染数据过程</p><ul><li><code>beforeCreate</code></li><li>父组件 <code>created </code></li><li>父组件 <code>beforeMount </code></li><li>子组件 <code>beforeCreate</code></li><li>子组件 <code>created</code></li><li>子组件 <code>beforeMount</code></li><li>子组件 <code>mounted</code></li><li>父组件 <code>mounted</code></li></ul></li><li><p>更新渲染数据过程</p><ul><li>父组件 <code>beforeUpdate</code></li><li>子组件 <code>beforeUpdate </code></li><li>子组件<code> updated</code></li><li>父组件 <code>updated</code></li></ul></li><li><p>销毁组件数据过程</p><ul><li>父组件<code> beforeDestroy</code></li><li>子组件 <code>beforeDestroy</code></li><li>子组件 <code>destroyed</code></li><li>父组件 <code>destroyed</code></li></ul></li></ol><h4 id="2-问题"><a href="#2-问题" class="headerlink" title="(2)  问题"></a>(2)  问题</h4><p>​我们从<code>props</code>中拿到的数据一般需要经过一些处理再放到模板中去使用。如果直接使用<code>props</code>值进行双向绑定，会提示错误：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Avoid mutating a <span class="hljs-keyword">prop</span> directly <span class="hljs-keyword">since</span> <span class="hljs-keyword">the</span> value will be overwritten whenever <span class="hljs-keyword">the</span> parent component re-renders. Instead, use a data <span class="hljs-keyword">or</span> computed <span class="hljs-keyword">property</span> based <span class="hljs-keyword">on</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">prop</span>&#x27;s value<br></code></pre></td></tr></table></figure><p>若在<code>mounted</code>钩子中对数据进行获取和处理，<code>mounted</code>钩子默认加载只会执行一次，若子组件<code>mounted</code>之后还未拿到父组件通过<code>props</code>传入的异步获取数据，则会出现数据无法同步的结果</p><h4 id="3-解决方式"><a href="#3-解决方式" class="headerlink" title="(3) 解决方式"></a>(3) 解决方式</h4><ol><li><p>用<code>v-if</code>来控制子组件的加载渲染时机。我们可以等到传递给子组件的数据有值之后，再加载子组件</p></li><li><p>在子组件中的<code>watch</code>属性中监听数据的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">newsHtml</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;&lt;p&gt;请输入内容&lt;/p&gt;&#x27;</span><br>    &#125;<br>&#125;,<br><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-title function_">newsHtml</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">html</span> = newVal<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure></li><li><p>使用<code>Vuex</code>进行状态管理。但这种父子组件传值的情况感觉没必要</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>实践输出</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>beforeCreate中访问methods中的函数</title>
    <link href="/2022/07/14/beforeCreate%E4%B8%AD%E8%AE%BF%E9%97%AEmethods%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <url>/2022/07/14/beforeCreate%E4%B8%AD%E8%AE%BF%E9%97%AEmethods%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>​在<code>beforeCreate</code>中打印当前实例对象<code>this</code>时，看到已经包含了定义的<code>methods</code>,但是在<code>beforeCreate</code>中调用<code>methods</code>中的方法时报错。<img src="/2022/07/14/beforeCreate%E4%B8%AD%E8%AE%BF%E9%97%AEmethods%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/image-20220705141100204.png" alt="image-20220705141100204"></p><p>​引用类型的值存在堆内存中，当我们使用<code>console.log</code>打印对象时，实际上它其实打印的时当前对象的快照。当展开对象时，浏览器重新去堆内存中读取当前最新的值。通过<code>debugger</code>打印，可以看到实际上在<code>beforeCreate</code>中是访问不到<code>methods</code>中的定义的方法的</p><p><img src="/2022/07/14/beforeCreate%E4%B8%AD%E8%AE%BF%E9%97%AEmethods%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/image-20220705140930798.png" alt="image-20220705140930798"></p><p><img src="/2022/07/14/beforeCreate%E4%B8%AD%E8%AE%BF%E9%97%AEmethods%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/image-20220705140909403.png" alt="image-20220705140909403"></p>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2.x源码学习思考与问题汇总-持续更新</title>
    <link href="/2022/07/13/Vue2-x%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83%E4%B8%8E%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2022/07/13/Vue2-x%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83%E4%B8%8E%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、为什么用function而不是ES6的class来实现Vue类？"><a href="#一、为什么用function而不是ES6的class来实现Vue类？" class="headerlink" title="一、为什么用function而不是ES6的class来实现Vue类？"></a>一、为什么用function而不是ES6的class来实现Vue类？</h3><p>​源码中<code>Vue</code>对象定义的部分</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span> <span class="hljs-params">(options)</span> &#123;<br>  <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;<br>    !(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Vue)<br>  ) &#123;<br>    warn(<span class="hljs-string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">this</span>._init(options)<br>&#125;<br></code></pre></td></tr></table></figure><p>既然<code>Vue</code>要规定只能通过<code>new</code>关键字调用，那为什么不直接使用<code>Class</code>呢？将上面代码换成</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vue</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-variable">_init</span>(<span class="hljs-variable">options</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>依旧可以实现简单的响应式页面</p><h4 id="补充：Class与构造函数"><a href="#补充：Class与构造函数" class="headerlink" title="补充：Class与构造函数"></a>补充：<code>Class</code>与构造函数</h4><ol><li><p><code>class</code>实质上可以看作一个语法糖，写法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br><span class="hljs-keyword">constructor</span>(x,y) &#123;<br><span class="hljs-keyword">this</span>.x = x;<br><span class="hljs-keyword">this</span>.y = y;<br>&#125;<br><br>toString() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x + <span class="hljs-string">&#x27;;&#x27;</span> + <span class="hljs-keyword">this</span>.y<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>采用构造函数方式实现时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Point</span>(<span class="hljs-params">x,y</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>&#125;<br><br><span class="hljs-title class_">Point</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-string">&#x27;;&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实际上，类的数据类型就是函数，类本身就是指向构造函数。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-built_in">Point</span>)    <span class="hljs-comment">// function</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Point</span> === <span class="hljs-built_in">Point</span>.prototype.constructor)  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>与使用构造函数一样，实例属性除非显示定义在其本身(即<code>this</code>对象)上，否则都是定义在其原型上</p></li><li><h4 id="与构造函数实现的不同在于"><a href="#与构造函数实现的不同在于" class="headerlink" title="与构造函数实现的不同在于"></a><strong>与构造函数实现的不同在于</strong></h4><ul><li><strong>类必须要使用<code>new</code>来调用</strong>，而普通构造函数不使用<code>new</code>也可以执行</li><li>类的所有方法都定义在<code>prototype</code>对象上，且均不可枚举。而构造函数用法下，其原型上定义的方法均可枚举(除了<code>constructor</code>)</li><li>类不存在变量提升，必须定义在前，使用在后</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3.x源码初探</title>
    <link href="/2022/07/13/Vue3%E5%88%9D%E6%8E%A2/"/>
    <url>/2022/07/13/Vue3%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<ol><li><h4 id="源码学习–调试环境搭建"><a href="#源码学习–调试环境搭建" class="headerlink" title="源码学习–调试环境搭建"></a>源码学习–调试环境搭建</h4><ul><li><p><code>Vue3</code>源码：记得是在<code>vuejs/core</code>目录下，<code>git clone https://github.com/vuejs/core.git</code></p></li><li><p>安装依赖： <code>yarn --ignore-scripts</code>，用<code>npm</code>会报错，会显示无法安装<code>&quot;workspace:*&quot;,</code></p></li><li><p>生成<code>sourcemap</code>文件，在<code>package.json</code>文件中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node scripts/dev.js --sourcemap&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>编译： <code>yarn dev</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 生成结果</span><br>packages\vue\dist\vue<span class="hljs-selector-class">.global</span><span class="hljs-selector-class">.js</span><br>packages\vue\dist\vue<span class="hljs-selector-class">.global</span><span class="hljs-selector-class">.js</span>.map<br></code></pre></td></tr></table></figure></li><li><p>调试范例代码：<code>yarn serve</code></p><p>![image-20220617103035576](..&#x2F;..&#x2F;..&#x2F;studyNote&#x2F;Vue&#x2F;1. Vue3初探+响应式原理.assets&#x2F;image-20220617103035576.png)</p></li></ul></li><li><h3 id="Vue3-依赖收集实现"><a href="#Vue3-依赖收集实现" class="headerlink" title="Vue3-依赖收集实现"></a><code>Vue3</code>-依赖收集实现</h3><ol><li><p>依赖收集</p><ul><li>建立响应数据<code>key</code>和更新函数之间的对应关系</li></ul></li><li><p>用法</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 设置响应函数<br>effct(() =&gt; &#123;console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">state</span>.foo)&#125;)<br><br>// 用户修改关联数据会触发响应函数<br><span class="hljs-keyword">state</span>.foo =&#x27;xxx&#x27;<br></code></pre></td></tr></table></figure></li><li><p>主要思路</p><ul><li><p>流程图</p><p>![image-20220619211915810](..&#x2F;..&#x2F;..&#x2F;studyNote&#x2F;Vue&#x2F;3-1. Vue3初探+响应式原理.assets&#x2F;image-20220619211915810.png)</p></li><li><p>主要函数</p><ul><li><code>effect</code>: 将回调函数(<code>effct(cb)</code>)保存起来备用(放入<code>effctTrack</code>)，并<strong>立即执行一次回调函数</strong>触发它里面一些响应数据的<code>getter</code></li><li><code>track</code>：<code>getter</code>中调用<code>track</code>，把前面存储的回调函数和当前的<code>target</code>、<code>key</code>之间建立映射关系<ul><li><code>track</code>函数逻辑：获取<code>effct</code>存入的函数(即<code>effctTrack</code>栈顶)；在<code>targetMap</code>中获取<code>target</code>对应的<code>Map</code>，若不存在则新建<code>map</code>；通过<code>key</code>获取到<code>map</code>中对应的<code>set</code>，若不存在则新建<code>set</code>；将传入<code>effct</code>的回调函数添加到<code>set</code>结构中</li></ul></li><li><code>trigger</code>：<code>setter</code>中调用<code>trigger</code>，把<code>target</code>、<code>key</code>对应的响应函数都执行一遍 <ul><li><code>trigger</code>函数逻辑：在<code>targetMap</code>中获取<code>target</code>对应的<code>Map</code>，若存在则获取<code>key</code>对应的<code>set</code>(回调函数集合)；遍历执行<code>set</code>中的函数</li></ul></li></ul></li></ul></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2.x源码学习准备</title>
    <link href="/2022/07/13/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/"/>
    <url>/2022/07/13/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h4 id="1-源码学习–调试环境搭建"><a href="#1-源码学习–调试环境搭建" class="headerlink" title="(1) 源码学习–调试环境搭建"></a>(1) 源码学习–调试环境搭建</h4><ul><li><p><code>Vue2</code>源码地址：<code>https://github.com/vuejs/vue.git</code></p><ul><li><code>windows</code>上一直报错，最后我直接下载<code>2.6.11</code>版本压缩包，按照下列操作运行没有问题<code>https://github.com/vuejs/vue/tree/v2.6.11</code></li></ul></li><li><p>安装依赖：<code>yarn</code>, 使用<code>npm</code>会因为无法安装一些依赖而报错</p></li><li><p>安装<code>rollup</code>：<code>yarn add rollup -g</code></p><ul><li><p>修改<code>dev</code>脚本，添加<code>sourcemap</code>，<code>package.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>运行开发命令：<code>yarn dev</code></p></li><li><p>我采用的<code>yarn</code>安装步骤：</p><ul><li><p>(前提是已经安装好<code>nodejs</code>)下载<a href="https://classic.yarnpkg.com/latest.msi">yarn</a></p></li><li><p>配置下载目录</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 全局安装目录</span><br>yarn<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> global-folder D:\Yarn\yarn_global<br><br><span class="hljs-comment"># 缓存目录</span><br>yarn<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> cache-folder D:\Yarn\yarn_cache<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-源码学习-准备工作"><a href="#2-源码学习-准备工作" class="headerlink" title="(2) 源码学习-准备工作"></a>(2) 源码学习-准备工作</h4><ol><li><p><code>Flow</code></p></li><li><p>源码目录<code>src</code>设计</p></li><li><p>源码构建方式</p><ul><li><p><code>RuntimeOnly</code></p><ul><li>在使用<code>RuntimeOnly</code>版本的<code>Vue.js</code>时，通常需要借助<code>webpack</code>的<code>vue-loader</code>工具将<code>.vue</code>文件编译为<code>javascript</code>对象，因为是在编译阶段做的，所以它只包含运行时的<code>Vue.js</code>代码，因此体积也会更加轻量</li></ul></li><li><p><code>Runtime + Compiler</code></p><ul><li><p>若我们没有对代码做预编译，但又使用了<code>Vue</code>的<code>template</code>属性传入一个字符串，则需要在客户端编译模板。因为在<code>Vue2</code>中，最终渲染都是通过<code>render</code>函数，若写了<code>template</code>属性吗，则需要编译成<code>render</code>函数，那么这个编译过程会发生在运行时，所以需要带有编译器的版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//  需要编译器的版本</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">template</span>:<span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123;hi&#125;&#125;&lt;/div&gt;&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">// 不需要编译器的版本</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">hi</span>)<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>积跬步以致千里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
